

Більша частина матеріалу лекції взята з  статті  [Обзор способов и протоколов аутентификации в веб-приложениях, Дмитрий Выростков](https://www.dataart.com.ua/news/obzor-sposobov-i-protokolov-autentifikatsii-v-veb-prilozheniyah/) 

# Автентифікація у веб-застосунках

### Процедури керування ідентифікацією та доступом (ІАМ) 

Керування ідентифікацією та доступом [Identity and Access Management](https://en.wikipedia.org/wiki/Identity_management) -  це набір політик та технологій для забезпечення доступу певних людей та/або застосунків до певних ресурсів. Системи керування ідентифікацією та доступом зокрема ідентифікують, підтверджують автентичність та надають дозволи до конкретних ресурсів.

- **[Ідентифікація](https://uk.wikipedia.org/wiki/%D0%86%D0%B4%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D1%96%D0%BA%D0%B0%D1%86%D1%96%D1%8F_(%D1%96%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D1%96%D0%B9%D0%BD%D0%B0_%D0%B1%D0%B5%D0%B7%D0%BF%D0%B5%D0%BA%D0%B0))** - це процедура розпізнавання користувача в системі. У залежності від ситуацій, це може бути зроблено за іменем користувача (`username` ), адресою електронної пошти, номером облікового запису, і тд.

- **[Автентифікація](https://uk.wikipedia.org/wiki/%D0%90%D0%B2%D1%82%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D1%96%D0%BA%D0%B0%D1%86%D1%96%D1%8F)** - процедура встановлення, що користувач насправді є тим, ким ідентифікувалися (від слова "authentic" - істинний, справжній). Це можна зробити, наприклад за перевіркою паролю.
- **[Авторизація](https://uk.wikipedia.org/wiki/%D0%90%D0%B2%D1%82%D0%BE%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D1%96%D1%8F)** - перевірка, що користувачу дозволено доступ до запитуваного ресурсу. 

Також до IAM відносяться процедури означення доступу.  

У сучасних системах існують як прості схеми автентифікації за іменем користувача та паролем, так і більш складні. У цій лекції розглядаються найбільш вживані.

Слід розуміти що до ВЕБ-застосунків можуть доступатися як користувачі так і інші застосунки. При цьому як правило ті ж самі застосунки використовують різні способи автентифікації для одних та інших.  

### Автентифікація користувачів за паролем

Наведені нижче схеми використовуються як правило для автентифікації користувачів (людей) а не сервісів чи застосунків.  

Цей метод грунтується на тому, що для успішної ідентифікації і автентифікації в системі користувач повинен надати ім'я (`username`) і пароль (`password`). Пара імені та паролю задається користувачем при його реєстрації в системі, при цьому в якості імені може виступати і адреса електронної пошти користувача. Стосовно веб-застосунків існує кілька стандартних протоколів для автентифікації за паролем, які розглянуто нижче.

#### HTTP автентифікація

Цей протокол існує дуже давно, він описаний ще в стандартах HTTP 1.0/1.1, але до цих пір активно застосовується в корпоративному середовищі. Стосовно веб-сайтів він працює наступним чином:

1. Сервер, при зверненні неавторизованого клієнта до захищеного ресурсу, відсилає HTTP статус "401 Unauthorized" і додає заголовок "WWW-Authenticate" із зазначенням схеми і параметрів автентифікації.
2. Браузер, при отриманні такої відповіді, автоматично показує діалог введення користувача і паролю. Користувач вводить деталі свого облікового запису.
3. У всіх наступних запитах до цього веб-сайту браузер автоматично додає HTTP заголовок "Authorization", в якому передаються дані користувача для аутентифікації сервером.
4. Сервер аутентифікує користувача за даними з цього заголовку. Рішення про надання доступу (авторизація) проводиться окремо на підставі ролі користувача, ACL або інших даних облікового запису.

Весь процес стандартизований і добре підтримується всіма браузерами і веб-серверами. Існує кілька схем аутентифікації, що відрізняються за рівнем безпеки. **Basic** —  найбільш проста схема, при якій `username` і `password` користувача передаються в заголовку `Authorization` в незашифрованому вигляді (`base64-encoded`). Однак при використанні HTTPS (HTTP over SSL) протоколу ця схема є відносно безпечною.
  		![img](authmedia/06d52f99b2bd48e585c79e4bbb5e4371.png)
  		рис. Приклад HTTP автентификації з використанням Basic схеми.  	

Більш захищеною є схема **Digest**, у якій сервер посилає унікальне значення `nonce`, а браузер передає хеш пароля користувача (зашифрований ппроль), обчислений з використанням зазначеного `nonce`. Це більш безпечна альтернатива Basic схеми при незахищених з'єднаннях, але схильна до атак типу man-in-the-middle. Крім того, використання цієї схеми не дозволяє застосувати сучасні хеш-функції для зберігання паролів користувачів на сервері. У системах Windows також використовуються схеми NTLM та Negotiate, які підтримуються більшістю браузерів і веб-серверів для Windows Active Directory.

Варто відзначити, що при використанні HTTP-аутентифікації у користувача немає стандартної можливості вийти з веб-застосунку, крім як закрити всі вікна браузера.

#### Автентифікація через форму

Для цього протоколу немає певного стандарту, тому всі його реалізації специфічні для конкретних систем, а точніше, для модулів аутентифікації. Цей спосіб працює це за наступним принципом: в веб-застосунок включається HTML-форма, в яку користувач повинен ввести своє ім'я та пароль. Вони відправляються на сервер через HTTP `POST` для аутентифікації. У разі успіху веб-застосунок створює маркер сесії (`session token`), який зазвичай поміщається в браузерні куки (`cookies`) . При наступних веб-запитах маркер сесії автоматично передається на сервер і дозволяє застосунку отримати інформацію про поточного користувача для авторизації запиту.

  ![img](authmedia/e8738696abcc4f45aebfeb41cf6c1ef6.png)
рис. Приклад автентифікації через форму.

Необхідно розуміти, що перехоплення маркерів сесії часто дає аналогічний рівень доступу, що і знання імені користувача та паролю. Тому всі комунікації між клієнтом і сервером повинні проводитися тільки по захищеному з'єднанню HTTPS.

#### Інші протоколи автентификації по паролю

Два протоколи, описані вище, успішно використовуються для аутентифікації користувачів на веб-сайтах. Але при розробці клієнт-серверних застосунків з використанням веб-сервісів (наприклад, iOS або Android), поряд з HTTP-автентифікацією, часто застосовуються нестандартні протоколи, в яких дані для автентифікації передаються в інших частинах запиту. Існує всього декілька місць, де можна передати ім'я і пароль користувача в HTTP запитах:

- URL запиту - вважається небезпечним варіантом, так як рядки URL можуть запам'ятовуватися браузерами, проксі і веб-серверами.
- Тіло запиту - безпечний варіант, але він застосовується лише для запитів, що містять тіло повідомлення (такі як POST, PUT, PATCH).
- HTTP-заголовки - оптимальний варіант, при цьому можуть використовуватися і стандартний заголовок Authorization (наприклад, з Basic-схемою), так і інші довільні заголовки.

#### Поширені вразливості і помилки реалізації

Автентифікації за паролем вважається не дуже надійним способом, так як паролі часто можна підібрати, а користувачі схильні використовувати прості і однакові паролі в різних системах, або записувати їх на клаптиках паперу. Якщо зловмисник зміг з'ясувати пароль, то користувач часто про це навіть не дізнається. Крім того, розробники застосунків можуть допустити ряд концептуальних помилок, що спрощують злом облікових записів. Нижче наведений список вразливостей, які найбільш часто зустрічаються у разі використання автентифікації за паролем, а саме коли веб застосунок:

- дозволяє користувачам створювати прості паролі.
- не захищений від можливості перебору паролів (brute-force attacks).
- сам генерує і поширює паролі користувачам, однак не вимагає зміни пароля після першого входу (тобто поточний пароль десь записаний).
- допускає передачу паролів по незахищеному HTTP-з'єднанню або в рядку URL.
- не використовує безпечні хеш-функції (методи шифрування) для зберігання паролів користувачів.
- не надає користувачам можливості зміни пароля або не повідомляє користувачам про зміну їх паролів.
- використовує вразливу функцію відновлення пароля, яку можна використовувати для отримання несанкціонованого доступу до інших облікових записів.
- не вимагає повторної автентифікації користувача для важливих дій: зміна пароля, зміни адреси доставки товарів і т.п.
- створює сесійні маркери таким чином, що вони можуть бути підібрані або передбачені для інших користувачів.
- допускає передачу сесійних маркерів по незахищеному HTTP-з'єднанню, або в рядку URL.
- вразливий для session fixation-атак (тобто не замінює сесійний ключ при переході анонімної сесії користувача в автентифіковану).
- не встановлює прапорці HttpOnly і Secure для browser cookies, що містять сесійні ключі.
- не знищує сесії користувача після короткого періоду неактивності або не надає функцію виходу з автентифікованої сесії.

### Автентифікація за сертифікатами 

**Сертифікат** представляє собою набір атрибутів, що ідентифікують власника, підписаним сертифікатом від **органу сертифікації** (*certificate authority* (**CA)**). Орган сертифікації виступає в ролі посередника, який гарантує справжність сертифікатів. Сертифікат криптографично пов'язаний з **закритим ключем** (відомим тільки власнику), яких зберігається у власника сертифіката і дозволяє однозначно підтвердити факт володіння сертифікатом.

На стороні клієнта сертифікат разом з закритим ключем можуть зберігатися в операційній системі, в браузері, в файлі, на окремому фізичному пристрої (smart card, USB token). Зазвичай закритий ключ додатково захищений паролем або PIN-кодом. 

У веб-застосунках традиційно використовують сертифікати стандарту `X.509`. Автентифікація за допомогою `X.509`-сертифіката відбувається в момент з'єднання з сервером і є частиною протоколу `SSL/TLS`. Цей механізм також добре підтримується браузерами, які дозволяють користувачеві вибрати і застосувати сертифікат, якщо веб-сайт допускає такий спосіб автентифікації.

  ![img](authmedia/6700a47a8bc0403dbc0021b3eb201be1.jpg)
рис. Використання сертифікату для автентифікації. 

Під час автентифікації сервер виконує перевірку сертифіката на підставі наступних правил:

1. Сертифікат повинен бути підписаний довіреним органом сертифікації CA (перевірка ланцюжка сертифікатів).
2. Сертифікат повинен бути дійсним на поточну дату (перевірка терміну дії).
3. Сертифікат не повинен бути відкликаний відповідним CA (перевірка списків виключення).

  ![img](authmedia/de5425ee9f1b462da2e49cc29ad7599a.png)
рис.  *Приклад X.509 сертифікату.*

Після успішної автентифікації веб-застосунок може виконати авторизацію запиту на підставі таких даних сертифікату, як `subject` (ім'я власника), `issuer` (емітент), `serial number` (серійний номер сертифіката) або `thumbprint` (відбиток відкритого ключа сертифіката).

Використання сертифікатів для автентифікації - куди більш надійний спосіб, ніж автентифікація за допомогою паролів. Це досягається створенням в процесі автентифікації цифрового підпису, наявність якого доводить факт застосування закритого ключа в конкретній ситуації. Однак труднощі з поширенням і підтримкою сертифікатів робить такий спосіб автентифікації малодоступним в широких колах.

### Автентифікація за одноразовими паролями та двофакторна автентифікація

Автентифікація за одноразовими паролями зазвичай застосовується додатково до автентифікації за паролями для реалізації **двофакторної автентифікації** (*two-factor authentication* (2FA)). У цій концепції користувачеві необхідно надати дані двох типів для входу в систему: щось, що він знає (наприклад, пароль), і щось, чим він володіє (наприклад, пристрій для генерації одноразових паролів). Наявність двох факторів дозволяє в значній мірі збільшити рівень безпеки, що можливо буде затребуване для певних видів веб-застосунків. Інший популярний сценарій використання одноразових паролів - додаткова автентифікація користувача під час виконання важливих дій: переказ грошей, зміна налаштувань і т.п.

Існують різні джерела для створення одноразових паролів. Найбільш популярні:

1. Апаратні або програмні маркери (токени), які можуть генерувати одноразові паролі на підставі секретного ключа, введеного в них, і поточного часу. Секретні ключі користувачів, які є фактором володіння, також зберігаються на сервері, що дозволяє виконати перевірку введених одноразових паролів. Приклад апаратної реалізацій токенів - [RSA SecurID](http://www.emc.com/security/rsa-securid/index.htm); програмної - застосунок [Google Authenticator](https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2).
2. Випадково генеруються коди, що передаються користувачеві через SMS або інший канал зв'язку. У цій ситуації фактор володіння - це телефон користувача (точніше - SIM-карта, прив'язана до певного номеру).
3. Роздруківка або `scratch card` зі списком заздалегідь сформованих одноразових паролів. Для кожного нового входу в систему потрібно ввести новий одноразовий пароль із зазначеним номером.

  ![img](authmedia/e9fc06fe151749839f2f48f24e9f148f.jpg)
рис.  *Апаратний маркер RSA SecurID генерує новий код кожні 30 секунд.*

У веб-застосунках такий механізм автентифікації часто реалізується за допомогою розширення автентифікації через форму: після первинної автентифікації за паролем, створюється сесія користувача, проте в контексті цієї сесії користувач не має доступу до застосунку до тих пір, поки він не виконає додаткову автентифікацію за одноразовим паролем.

### Автентифікація за ключами доступу (API key)

Цей спосіб найчастіше використовується для автентифікації пристроїв, сервісів або інших застосунків при зверненні до веб-сервісів. Тут в якості секрету застосовуються **ключі доступу** (**access key**, **API key**) - довгі унікальні рядки, що містять довільний набір символів, що по суті замінюють собою комбінацію імені користувача та паролю.

У більшості випадків, сервер генерує ключі доступу за запитом користувачів, які далі зберігають ці ключі в клієнтських застосунках. При створенні ключа також можливо обмежити термін дії і рівень доступу, який отримає клієнтська програма при автентифікації за допомогою цього ключа.

Розглянемо приклад застосування автентифікації за ключем - хмара Amazon Web Services. Припустимо, у користувача є веб-застосунок, що дозволяє завантажувати і переглядати фотографії, і він хоче використовувати сервіс `Amazon S3` для зберігання файлів. В такому випадку, користувач через консоль AWS може створити ключ, що має обмежений доступ до хмари: тільки читання / запис його файлів в Amazon S3. Цей ключ в результаті можна застосувати для аутентифікації веб-застосунку в хмарі AWS.

  ![img](authmedia/c498e2947c224603a6e7d3da859fb8a9.png)
рис.  Приклад застосування автентифікації за ключем.

Використання ключів дозволяє уникнути передачі пароля користувача стороннім застосункам (у прикладі вище користувач зберіг у веб-застосунку не свій пароль, а ключ доступу). Ключі мають значно більшу складність в порівнянні з паролями, тому їх практично неможливо підібрати. Крім того, якщо ключ був розкритий, це не призводить до компрометації основного облікового запису користувача - достатньо лише анулювати цей ключ і створити новий.

З технічної точки зору ключі можуть передаватися в різних частинах HTTP-запиту: URL-запиті, тілі чи заголовку. Як і в випадку автентифікації за паролем, найбільш оптимальний варіант - використання заголовків. У деяких випадках використовують HTTP-схему `Bearer` для передачі токена в заголовку `Authorization: Bearer [token]`. Щоб уникнути перехоплення ключів, з'єднання з сервером має бути обов'язково захищене протоколом SSL/TLS.

  ![img](authmedia/54aa75db071c4078b039a2643003c53c.png)
рис.  Приклад автентифікації за ключем доступу, переданого в HTTP заголовку.

Існують більш складні схеми автентифікації за ключами для незахищених з'єднань. У цьому випадку, ключ зазвичай складається з двох частин: публічної і секретної (приватної). Публічна частина використовується для ідентифікації клієнта, а приватна частина дозволяє згенерувати підпис. Наприклад, за аналогією з схемою `digest authentication`, сервер може послати клієнту унікальне значення `nonce` або `timestamp`, а клієнт - повернути хеш цього значення, обчислений з використанням секретної частини ключа. Це дозволяє уникнути передачі всього ключа в оригінальному вигляді і захищає від атак.

### Автентифікація за маркерами (токенами)

Такий спосіб автентифікації найчастіше застосовується при побудові розподілених систем, де один застосунок - **провайдер сервісів**(**service provider**) делегує функцію автентифікації користувачів іншому застосунку - **сервісу/провайдеру автентифікації** (**identity provider** або **authentication service** ). Провайдер сервісів (постачальник послуг) - застосунок, який надає доступ до своїх сервісів через API. Але замість того, щоб автентифікувати користувача безпосередньо, він користується сервісами провайдера автентифікації.     

Типовий приклад цього способу - вхід в застосунок через обліковий запис в соціальних мережах. Тут соціальні мережі є сервісами автентифікації, а застосунок довіряє функцію автентифікації користувачів соціальним мережам. Наприклад в https://www.slideshare.net/ можна зайти через `LinkedIn` або `Facebook`.   

Реалізація цього способу полягає в тому, що провайдер автентифікації (identity provider) надає достовірні відомості про користувача в вигляді **маркера** (**токен**, **token**), а застосунок провайдеру сервісів (service provider) використовує цей токен для ідентифікації, автентифікації і авторизації користувача.

На загальному рівні, весь процес виглядає наступним чином:

1. Клієнт (клієнтський застосунок) автентифікується у провайдері автентифікації одним із характерним для нього способів,  (пароль, ключ доступу, сертифікат, Kerberos, і т.д.).
2. Клієнт просить провайдера автентифікації надати йому маркер для конкретного застосунку (провайдера сервісів). Провайдер ідентифікації генерує маркер і відправляє його клієнту.
3. Клієнт автентифікується в необхідному застосунку (провайдера сервісів) за допомогою цього маркеру.

  ![img](authmedia/8144cb759d9f42cfb9f1841b1cee48c0.png)
рис.  Приклад автентифікації «активного» клієнта за допомогою маркера, переданого за допомогою  схеми Bearer: trust - дозвіл. 

Процес, описаний вище, відображає механізм аутентифікації **активного** клієнта, тобто такого, який може виконувати запрограмовану послідовність дій (наприклад, застосунки iOS/Android). Браузер є  **пасивним** клієнтом в тому сенсі, що він тільки може відображати сторінки, що запитуються користувачем. У цьому випадку автентифікація досягається за допомогою автоматичного перенаправлення браузера між веб-застосунками провайдерів автентифікації та сервісів.

  ![img](authmedia/d971efb45511418f91645db736f30979.png)
рис.  Приклад автентификації «пасивного» клієнта шляхом перенаправлення запитів.

Існує кілька стандартів, які в точності означують протокол взаємодії між клієнтами (активними і пасивними) і застосунками провайдерів, а також формат підтримуваних маркерів. Серед найбільш популярних стандартів - OAuth, OpenID Connect, SAML, і WS-Federation. Деяка інформація про перші два наведені нижче.

Сам маркер зазвичай представляє собою структуру даних, яка містить інформацію про те, хто його згенерував, хто може бути одержувачем, термін дії та відомості про самого користувача (claims). Крім того, маркер додатково підписується для запобігання несанкціонованих змін і гарантій автентичності.

При автентифікації за допомогою маркера провайдер сервісів повинен виконати наступні перевірки:

- маркер був виданий довіреним провайдером автентифікації .
- маркер призначається поточному провайдеру сервісів .
- термін дії маркера ще не закінчився .
- маркер справжній і не був змінений (перевірка підпису).

У разі успішної перевірки провайдер сервісів виконує авторизацію запиту на підставі даних про користувача, що містяться в маркері.

Існує кілька поширених форматів маркерів для веб-застосунків, усі вони захищені шифруванням:

- Simple Web Token (SWT) - у форматі кодування форми HTML
- JSON Web Token (JWT) - у форматі JSON
- Security Assertion Markup Language (SAML) - в XML-форматі

### Стандарты OAuth и OpenID Connect

Стандарт **OAuth** (Open Authorization) означує механізм отримання доступу одного застосунку до іншого від імені користувача без необхідності вводу імені користувача та паролю. 

OAuth дозволяє користувачам, як власникам ресурсів (`resource owner`) роздавати клієнтським застосункам (`client`)  маркери доступу до власних даних , що розміщуються на серверах ресурсів (`resource server`). Кожен маркер доступу надає доступ до конкретного серверу ресурсів (наприклад, сайту редагування відео) навіть до конкретних ресурсів на них (наприклад, тільки відео від конкретного альбому) та на означений термін (наприклад, на наступні 2 години). Це дозволяє користувачам надавати доступ клієнтським застосункам до їх інформації, що зберігається на інших серверах — провайдерів сервісів, не передаючи повною мірою самих даних та без застосування імені/паролю. 

Перша версія стандарту розроблялася в 2007 - 2010 рр., а поточна версія 2.0 опублікована в 2012 р Версія 2.0 значно розширює і в той же час спрощує стандарт, але зворотно несумісний з версією 1.0. Зараз OAuth 2.0 дуже популярний і використовується повсюдно для надання делегованого доступу і третє-сторонньої автентифікації користувачів.

У загальному весь процес складається з декількох кроків:

1. Користувач (`resource owner`) дає дозвіл клієнтському застосунку (`client`) на доступ до певного ресурсу у вигляді гранту. Що таке грант, розглянемо трохи нижче.
2. Застосунок звертається до сервера авторизації та отримує маркер доступу до ресурсу в обмін на свій грант. При виклику застосунок додатково автентифікується за допомогою ключа доступу, виданим йому за попередньою реєстрацією.
3. Програма використовує цей маркер для отримання необхідних даних від сервера ресурсів (в нашому випадку - сервіс Gmail).

  ![img](authmedia/3334c8d4135048d6bdd2baa34c77ae43.png)
рис.  Взаємодія компонентів у стандарті OAuth.

Стандарт описує чотири види **грантів**, які означують можливі сценарії застосування:

1. Authorization Code - цей грант користувач може отримати від сервера авторизації після успішної автентифікації і підтвердження згоди на надання доступу. Такий спосіб найбільш часто використовується у веб-застосунках. 
2. Implicit - застосовується, коли у застосунку немає можливості безпечно отримати маркер від сервера авторизації (наприклад, JavaScript-застосунок у браузері). У цьому випадку грант є маркером, отриманим від сервера авторизації, а крок №2 виключається зі сценарію вище.
3. Resource Owner Password Credentials - грант є парою `username/password` користувача. Може застосовуватися, якщо застосунок є «інтерфейсом» для сервера ресурсів (наприклад, застосунок - мобільний клієнт для Gmail).
4. Client Credentials - у цьому випадку немає ніякого користувача, а застосунок отримує доступ до своїх ресурсів за допомогою власних джерел доступу (виключається крок №1). 

Стандарт не означує формат маркеру, який отримує застосунок: в сценаріях, адресованих стандартом, з застосунком немає необхідності аналізувати маркер, так як він лише використовується для отримання доступу до ресурсів. Тому ні маркер, ні грант самі по собі не можуть бути використані для автентифікації користувача. Однак якщо з застосунком необхідно отримати достовірну інформацію про користувача, існують кілька способів це зробити:

1. Як правило API сервера  ресурсів включають операцію, яка надає інформацію про самого користувача (наприклад, `/me` у Facebook API). Застосунок може виконувати цю операцію кожного разу після отримання маркеру для ідентифікації клієнту. Такий метод інколи називають *псевдо-автентифікацією*. 
2. Використовувати стандарт **OpenID Connect**, розроблений як шар облікових даних поверх OAuth (опублікований в 2014 р). Відповідно до цього стандарту, сервер авторизації надає додатковий маркер авторизації на кроці № 2. Цей маркер в форматі JWT буде містити набір певних полів з інформацією про користувача.

Варто зауважити, що OpenID Connect, який замінив попередні версії стандарту OpenID 1.0 і 2.0, також містить набір необов'язкових доповнень для пошуку серверів авторизації, динамічної реєстрації клієнтів і управління сесією користувача.

https://cloud.google.com/docs/authentication

https://habr.com/ru/post/491116/ 

https://www.digitalocean.com/community/tutorials/oauth-2-ru

https://docs.oracle.com/cd/E74890_01/books/RestAPI/RestAPI_Overview13.html



Для проб

https://swapi.dev/

https://jigsaw.w3.org/HTTP

https://demo.c2id.com/oidc-client/

https://developers.google.com/oauthplayground/

